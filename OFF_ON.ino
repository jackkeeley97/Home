#include <FrequencyTimer2.h>

//http://embed.plnkr.co/3VUsekP3jC5xwSIQDVHx/preview

#define ROW_1 2
#define ROW_2 3
#define ROW_3 4
#define ROW_4 5
#define ROW_5 6
#define ROW_6 7
#define ROW_7 8
#define ROW_8 9

#define COL_1 10
#define COL_2 11
#define COL_3 12
#define COL_4 13
#define COL_5 A0
#define COL_6 A1
#define COL_7 A2
#define COL_8 A3

const byte rows[] = {
    ROW_1, ROW_2, ROW_3, ROW_4, ROW_5, ROW_6, ROW_7, ROW_8
};

// The display buffer
// It's prefilled with a smiling face (1 = ON, 0 = OFF)
byte OFF[] = {B00000000,B11011011,B01010010,B01011011,B01010010,B01010010,B11010010,B00000000};
byte ON[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B00000000,B00000000,B00000000};
byte ONA[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B00000000,B11111111};
byte ONB[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B10000000,B11111111};
byte ONC[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11000000,B11111111};
byte OND[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11100000,B11111111};
byte ONE[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11110000,B11111111};
byte ONF[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11111000,B11111111};
byte ONG[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11111100,B11111111};
byte ONH[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11111110,B11111111};
byte ONI[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B11111111,B11111111,B11111111};
byte ONJ[] = {B11101001,B10101101,B10101011,B11101001,B00000000,B00000100,B00101000,B00010000};
byte SPEAKERONF[] = {B00001000,B00000100,B01010010,B11001010,B11001010,B01010010,B00000100,B00001000};
byte SPEAKERONH[] = {B00000000,B00000000,B01010000,B11001000,B11001000,B01010000,B00000000,B00000000};
byte SPEAKEROFF[] = {B00000000,B00000000,B01000000,B11000000,B11000000,B01000000,B00000000,B00000000};
byte DTWO[] = {B00000000,B11001100,B10100010,B10010010,B10010010,B10100100,B11001111,B00000000};
byte GUNOFF[] = {B00000000,B10010000,B11111000,B11111100,B11111000,B01000000,B01000000,B01000000};
byte GUNON[] = {B00000000,B10010000,B11111000,B11111101,B11111000,B01000000,B01000000,B01000000};
byte LILHEART[] = {B00000000,B00000000,B01100110,B01111110,B01111110,B00111100,B00011000,B00000000};
byte BIGHEART[] = {B00000000,B11100111,B11111111,B11111111,B11111111,B01111110,B00111100,B00011000};
byte TODOS[] = {B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111};
byte EX[] = {B00000000,B00010000,B00010000,B00010000,B00010000,B00000000,B00010000,B00000000};
byte A[] = {B00000000,B00011000,B00100100,B00100100,B00111100,B00100100,B00100100,B00000000};
byte B[] = {B01111000,B01001000,B01001000,B01110000,B01001000,B01000100,B01000100,B01111100};
byte C[] = {B00000000,B00011110,B00100000,B01000000,B01000000,B01000000,B00100000,B00011110};
byte D[] = {B00000000,B00111000,B00100100,B00100010,B00100010,B00100100,B00111000,B00000000};
byte E[] = {B00000000,B00111100,B00100000,B00111000,B00100000,B00100000,B00111100,B00000000};
byte F[] = {B00000000,B00111100,B00100000,B00111000,B00100000,B00100000,B00100000,B00000000};
byte G[] = {B00000000,B00111110,B00100000,B00100000,B00101110,B00100010,B00111110,B00000000};
byte H[] = {B00000000,B00100100,B00100100,B00111100,B00100100,B00100100,B00100100,B00000000};
byte I[] = {B00000000,B00111000,B00010000,B00010000,B00010000,B00010000,B00111000,B00000000};
byte J[] = {B00000000,B00011100,B00001000,B00001000,B00001000,B00101000,B00111000,B00000000};
byte K[] = {B00000000,B00100100,B00101000,B00110000,B00101000,B00100100,B00100100,B00000000};
byte L[] = {B00000000,B00100000,B00100000,B00100000,B00100000,B00100000,B00111100,B00000000};
byte M[] = {B00000000,B00000000,B01000100,B10101010,B10010010,B10000010,B10000010,B00000000};
byte N[] = {B00000000,B00100010,B00110010,B00101010,B00100110,B00100010,B00000000,B00000000};
byte O[] = {B00000000,B00111100,B01000010,B01000010,B01000010,B01000010,B00111100,B00000000};
byte P[] = {B00000000,B00111000,B00100100,B00100100,B00111000,B00100000,B00100000,B00000000};
byte Q[] = {B00000000,B00111100,B01000010,B01000010,B01000010,B01000110,B00111110,B00000001};
byte R[] = {B00000000,B00111000,B00100100,B00100100,B00111000,B00100100,B00100100,B00000000};
byte S[] = {B00000000,B00111100,B00100000,B00111100,B00000100,B00000100,B00111100,B00000000};
byte T[] = {B00000000,B01111100,B00010000,B00010000,B00010000,B00010000,B00010000,B00000000};
byte U[] = {B00000000,B01000010,B01000010,B01000010,B01000010,B00100100,B00011000,B00000000};
byte V[] = {B00000000,B00100010,B00100010,B00100010,B00010100,B00010100,B00001000,B00000000};
byte W[] = {B00000000,B10000010,B10010010,B01010100,B01010100,B00101000,B00000000,B00000000};
byte X[] = {B00000000,B01000010,B00100100,B00011000,B00011000,B00100100,B01000010,B00000000};
byte Y[] = {B00000000,B01000100,B00101000,B00010000,B00010000,B00010000,B00010000,B00000000};
byte Z[] = {B00000000,B00111100,B00000100,B00001000,B00010000,B00100000,B00111100,B00000000};

byte TWO[] = {B00000000,B00111000,B00000100,B00001100,B00010000,B00100000,B00111100,B00000000};

byte SMILE[] = {B00000000,B01100110,B01100110,B00000000,B01111110,B01111110,B00111100,B00000000};

byte C1[] = {B10000000,B10000000,B10000000,B10000000,B10000000,B10000000,B10000000,B10000000};
byte C2[] = {B01000000,B01000000,B01000000,B01000000,B01000000,B01000000,B01000000,B01000000};
byte C3[] = {B00100000,B00100000,B00100000,B00100000,B00100000,B00100000,B00100000,B00100000};
byte C4[] = {B00010000,B00010000,B00010000,B00010000,B00010000,B00010000,B00010000,B00010000};
byte C5[] = {B00001000,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000,B00001000};
byte C6[] = {B00000100,B00000100,B00000100,B00000100,B00000100,B00000100,B00000100,B00000100};
byte C7[] = {B00000010,B00000010,B00000010,B00000010,B00000010,B00000010,B00000010,B00000010};
byte C8[] = {B00000001,B00000001,B00000001,B00000001,B00000001,B00000001,B00000001,B00000001};

byte R1[] = {B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000};
byte R2[] = {B00000000,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000};
byte R3[] = {B00000000,B00000000,B11111111,B00000000,B00000000,B00000000,B00000000,B00000000};
byte R4[] = {B00000000,B00000000,B00000000,B11111111,B00000000,B00000000,B00000000,B00000000};
byte R5[] = {B00000000,B00000000,B00000000,B00000000,B11111111,B00000000,B00000000,B00000000};
byte R6[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B00000000,B00000000};
byte R7[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111,B00000000};
byte R8[] = {B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B11111111};

byte DRL[] = {B00000001,B00000010,B00000100,B00001000,B00010000,B00100000,B01000000,B10000000};
byte DLR[] = {B10000000,B01000000,B00100000,B00010000,B00001000,B00000100,B00000010,B00000001};

byte SQ1[] = {B11111111,B10000001,B10000001,B10000001,B10000001,B10000001,B10000001,B11111111};
byte SQ2[] = {B01000010,B11111111,B01000010,B01000010,B01000010,B01000010,B11111111,B01000010};
byte SQ3[] = {B00100100,B00100100,B11111111,B00100100,B00100100,B11111111,B00100100,B00100100};
byte SQ4[] = {B00011000,B00011000,B00011000,B11111111,B11111111,B00011000,B00011000,B00011000};

byte CN1[] = {B10000001,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B10000001};
byte CN2[] = {B11000011,B11000011,B00000000,B00000000,B00000000,B00000000,B11000011,B11000011};
byte CN3[] = {B11000011,B11100111,B01100110,B00000000,B00000000,B01100110,B11100111,B11000011};
byte CN4[] = {B11000011,B11100111,B01111110,B00111100,B00111100,B01111110,B11100111,B11000011};
byte CN5[] = {B00000000,B01100110,B01111110,B00111100,B00111100,B01111110,B01100110,B00000000};
byte CN6[] = {B00000000,B00000000,B00111100,B00111100,B00111100,B00111100,B00000000,B00000000};
byte CN7[] = {B00000000,B00000000,B00100100,B00011000,B00011000,B00100100,B00000000,B00000000};
byte CN8[] = {B00000000,B00000000,B00000000,B00011000,B00011000,B00000000,B00000000,B00000000};

byte SOUND1[] = {B00001000,B01011000,B11011101,B11011111,B11111111,B11111111,B11111111,B11111111};
byte SOUND2[] = {B00010000,B01010010,B01010010,B01110110,B11111110,B11111111,B11111111,B11111111};
byte SOUND3[] = {B00100010,B00101010,B01111010,B11111111,B11111111,B11111111,B11111111,B11111111};

byte EVERYOTHER1[] = {B10101010,B10101010,B10101010,B10101010,B10101010,B10101010,B10101010,B10101010};
byte EVERYOTHER2[] = {B01010101,B01010101,B01010101,B01010101,B01010101,B01010101,B01010101,B01010101};
byte EVERYOTHER3[] = {B11111111,B00000000,B11111111,B00000000,B11111111,B00000000,B11111111,B00000000};
byte EVERYOTHER4[] = {B00000000,B11111111,B00000000,B11111111,B00000000,B11111111,B00000000,B11111111};

byte INVERSE[] =  {B00000000,B00000000,B00000000,B11111111,B11111111,B11111111,B11111111,B11111111};

float timeCount = 0;

void setup() {
    // Open serial port
    Serial.begin(9600);
    
    // Set all used pins to OUTPUT
    // This is very important! If the pins are set to input
    // the display will be very dim.
    for (byte i = 2; i <= 13; i++)
        pinMode(i, OUTPUT);
    pinMode(A0, OUTPUT);
    pinMode(A1, OUTPUT);
    pinMode(A2, OUTPUT);
    pinMode(A3, OUTPUT);
}

void loop() {
  // This could be rewritten to not use a delay, which would make it appear brighter
delay(0);
timeCount += 1;
if(timeCount <  70) {
drawScreen(OFF);
} else if (timeCount <  1) {
// do nothing
} else if (timeCount <  50) {
drawScreen(ON);
} else if (timeCount <  1) {
// nothing
} else if (timeCount <  100) {
drawScreen(ONA);
} else if (timeCount <  1) {
// nothing
} else if (timeCount <  150) {
drawScreen(ONB);
} else if (timeCount <  1) {
// nothing
} else if (timeCount <  200) {
drawScreen(ONC);
} else if (timeCount <  1) {
// nothing
} else if (timeCount <  250) {
drawScreen(OND);
} else if (timeCount <  1) {
  
} else if (timeCount <  300) {
 drawScreen(ONE);
} else if (timeCount <  1) {
// do nothing
} else if (timeCount <  350) {
drawScreen(ONF);
} else if (timeCount <  1) {
// nothing
} else if (timeCount <  400) {
drawScreen(ONG);
} else if (timeCount <  1) {

} else if (timeCount <  450) {
drawScreen(ONH);
} else if (timeCount <  1) {

} else if (timeCount <  500) {
drawScreen(ONI);
} else if (timeCount <  1) {

} else if (timeCount <  750) {
drawScreen(ONJ);
} else if (timeCount <  1) {

//} else if (timeCount <  790) {
//drawScreen(U);
//} else if (timeCount <  1) {

//} else if (timeCount <  830) {
//drawScreen(I);
//} else if (timeCount <  1) {

//} else if (timeCount <  870) {

//} else if (timeCount <  1) {
  
//} else if (timeCount <  910) {
//  drawScreen(O);
//} else if (timeCount <  1) {

} else {
// back to the start
timeCount = 0;
}
}
 void  drawScreen(byte buffer2[]){
     
    
   // Turn on each row in series
    for (byte i = 0; i < 8; i++) {
        setColumns(buffer2[i]); // Set columns for this specific row
        
        digitalWrite(rows[i], LOW);
        delay(1); // Set this to 50 or 100 if you want to see the multiplexing effect!
        digitalWrite(rows[i], HIGH);
        
    }
}


void setColumns(byte b) {
    digitalWrite(COL_1, (b >> 0) & 0x01); // Get the 1st bit: 10000000
    digitalWrite(COL_2, (b >> 1) & 0x01); // Get the 2nd bit: 01000000
    digitalWrite(COL_3, (b >> 2) & 0x01); // Get the 3rd bit: 00100000
    digitalWrite(COL_4, (b >> 3) & 0x01); // Get the 4th bit: 00010000
    digitalWrite(COL_5, (b >> 4) & 0x01); // Get the 5th bit: 00001000
    digitalWrite(COL_6, (b >> 5) & 0x01); // Get the 6th bit: 00000100
    digitalWrite(COL_7, (b >> 6) & 0x01); // Get the 7th bit: 00000010
    digitalWrite(COL_8, (b >> 7) & 0x01); // Get the 8th bit: 00000001
    
    // If the polarity of your matrix is the opposite of mine
    // remove all the '~' above.
}
